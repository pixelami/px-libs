package org.pixelami.xml;

//@:build(org.pixelami.xml.ElementRegistryBuilder.buildRegistry())
class ElementRegistry
{
    static var _instance:ElementRegistry;
    public static function getInstance()
    {
        if(_instance == null) _instance = new ElementRegistry();
        return _instance;
    }

    var registry:Hash<Class<Dynamic>>;
    var classNameRegistry:Hash<String>;
    var classNameElementMap:Hash<String>;
    var namespaces:Hash<Namespace>;

    public function new()
    {
        registry = new Hash<Class<Dynamic>>();
        classNameRegistry = new Hash<String>();
        classNameElementMap = new Hash<String>();
        namespaces = new Hash<Namespace>();

        processAutoGeneratedMappings();
    }

    public function mapElementToClass(element:String, clazz:Class<Dynamic>):Void
    {
        registry.set(element,clazz);
        classNameElementMap.set(Type.getClassName(clazz), element);
    }

    public function getClassForElement(element:String):Class<Dynamic>
    {
        return registry.get(element);
    }

    public function getElementForClass(clazz:Class<Dynamic>):String
    {
        return classNameElementMap.get(Type.getClassName(clazz));
    }


    public function getClassNameForElement(element:Xml):String
    {
        processNamspaces(element);

        if(classNameRegistry.exists(element.nodeName)) return classNameRegistry.get(element.nodeName);
        // add to a string registry too - to avoid overhead of lookup each time
        var className:String = Type.getClassName(getClassForElement(element.nodeName));
        classNameRegistry.set(element.nodeName,className);
        return className;
    }

    public var manfiest (default,set_manifest):Xml ;

    function set_manifest(value:Xml):Xml
    {
        for(el in value.elements())
        {
            trace(el);

            var className:String = el.get("class");
            var registryKey:String = el.get("prefix") + ":" + el.get("name");
            var type:Class<Dynamic> = Type.resolveClass(className);
            if(type != null)
            {
                registry.set(registryKey,type);
            }
        }
        return value;
    }

    function processNamspaces(element:Xml)
    {
        for(attr in element.attributes())
        {
            if(StringTools.startsWith(attr, "xmlns"))
            {
                var name:String = parseNamespaceAttribute(attr);
                var uri:String = element.get(attr);
                var ns:Namespace = new Namespace(name, uri);
                namespaces.set(uri, ns);
            }
        }
    }

    function parseNamespaceAttribute(attr:String):String
    {
        var start:Int = attr.indexOf(":")+1;
        var name:String = attr.substr(start, attr.length - start);
        return name;
    }

    function processAutoGeneratedMappings()
    {
        // contents generated by ElementRegistryBuilder
    }

	public function toString():String
	{
		var buf:StringBuf = new StringBuf();
		buf.add("[ElementRegistry ");
		for(k in registry.keys())
		{
			buf.add("{");
			buf.add(k);
			buf.add(" => ");
			buf.add(Type.getClassName(registry.get(k)));
			buf.add("}");
		}
		buf.add(" ]");
		return buf.toString();
	}

}
